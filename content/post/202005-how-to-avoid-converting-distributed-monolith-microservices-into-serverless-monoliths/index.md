+++
title = "[译] 从Microservices到Serverless: 如何避免将分布式单体微服务转化为Serverless单体"

date = 2020-05-17
lastmod = 2020-05-17
draft = true

tags = ["EDA","Serverless"]
summary = "从Microservices到Serverless: 如何避免将分布式单体微服务转化为Serverless单体"
abstract = "从Microservices到Serverless: 如何避免将分布式单体微服务转化为Serverless单体"

[header]
image = ""
caption = ""

+++

英文原文来自 [From Microservices to Serverless: How to avoid converting “Distributed monolith” microservices into “Serverless monoliths”](https://medium.com/the-theam-journey/how-to-avoid-converting-distributed-monolith-microservices-into-serverless-monoliths-f48061a9ff7e)，作者 [Álvaro López Espinosa](https://medium.com/@alvaroloes)。

> 备注：快速翻译（机翻+人工校对，没有精修），质量不高，一般阅读可以，不适合传播，谢绝转载。



**向过去学习：把单体变成...... 更糟糕的单体**

当微服务成为主流时，很多公司开始将其单体系统迁移到分布式微服务架构。其优势是显而易见的：

- 提高了可扩展性
- 部署时的灵活性
- 为特定用例选择合适的技术（或语言）的能力
- 将较高优先级的服务与较低优先级的服务隔离开来，以防止整个系统出现级联故障。
- 其他

但是当你第一次接触一项技术并被炒作所拖累时，通常会发生这样的情况，很多早期的微服务实现都没有做好。

那些为单体系统创建最佳架构的人，也试图将这些知识和经验重用到创建微服务架构上。他们把现有的代码分解成逻辑块，没有考虑到依赖关系，用HTTP请求代替了直接的方法调用。这导致了通常所说的 "分布式单体"：

- 不再让应用程序由多个耦合在一起的模块组成，这些模块通过计算机的内存空间进行方法调用.....

- ...我们现在的应用程序，它由多个耦合在一起的微服务组成，这些微服务通过网络进行的HTTP调用。

你可能已经猜到了，在这两种情况下，我们的架构几乎是一样的，但我们新的微服务版本更糟糕：它更脆弱，因为我们用网络当成 "胶水 " 来把模块粘在一起，这比在同一台机器上直接调用方法更不可靠。

![](images/monilithic-application.png)

这是在单体应用，或者说是 "分布式单体 "中使用的架构。`Class/Module/Microservice A ` 使用 "Some Interface"（REST API或直接方法调用），通过一些 "魔法"（网络或计算机内存）调用 `Class/Module/Microservice B` 中的方法。

**这是否意味着，微服务架构是个谎言，它比单体架构更差？**

不，微服务只是一个解决特定问题的特定工具，和任何工具一样，你需要了解如何正确使用它。用螺丝刀去敲钉子可能会在紧急情况下起作用，但你的下场可能会比你开始的时候更糟糕：你会把螺丝刀弄断，而钉子也无法正常敲入。螺丝刀是一个无用的工具吗？当然不是。

为了正确使用微服务这个 "工具"，你需要为它**创建正确的架构**，这与单体架构有很大的区别。这些正确的架构通常都是这样：

- 微服务，因为它们本身就是一个较小的系统，所以实际上可以独立工作
- 最低限度的直接依赖关系
- 去正态化数据（Denormalized Data）（做得正确）
- 服务的可发现性
- 故障容错
- 事件驱动（反应式）通信

### 一举两得

试想一下，我们是那些迁移到 "分布式单体"的公司之一，我们正在承受着它的后果。我们现在知道这是我们过去犯的一个错误，但我们已经吸取了教训，我们不会再犯同样的错误。

现在所有的炒作都在转向Serverless（可以看成是微服务的一种极端形式），但这一次是真的! Serverless是一个更灵活的工具，甚至比微服务更有优势：

- 你可以不管用处理基础设施。Serverless = 无需服务器管理!
- 无限的可扩展性。Lambdas(或functions as a service, FaaS))是完全并行化的，在需要的时候，由提供者按需创建。
- 节约成本：你不为你不使用的资源付费（闲置时间不收费）
- 对用例的精细化控制，因为每个用例都有自己独立的FaaS。
- 它拥抱了典型用例的第三方服务的可重用性（Auth0、DynamoDB、S3、Kinesis等）。

OK，是时候把我们目前的 "分布式单体" 架构转移到使用Amazon Web Services的Serverless上了。因此，我们做了如下的事情。

1. 创建一个AWS账户
2. 将微服务拆分成Lambdas。有几种方法可以做到这一点：

	- 一个Lambda = 一个微服务
	- 一个Lambda=一个endpoint及其所有动词（GET, POST, PUT, DELETE...）。
	- 一个Lambda=一个endpoint的一个动词

3. 将日志迁移到CloudWatch
4. 设置提醒
5. 正确配置安全和IAM角色
6. 将数据层迁移到亚马逊解决方案之一（S3、DynamoDB...）。

就这样！我们现在有了一个成熟的无服务器应用，而不是一个蹩脚的 "分布式单体"。让我们发布一篇文章，介绍一下我们公司是如何拥抱Serverless的，以及从微服务架构迁移到Serverless是多么的容易。

这一次比我们预期的要容易得多!

![](images/it-is-a-trap.png)

## 欢迎进入新的 "Serverless单体" 时代

你可能已经猜到了，我们又犯了同样的错误，因为我们用以前的单体或微服务架构的思维方式和设计模式来创建Serverless架构。

我们微服务之间的耦合发生了变化吗? 它仍然存在! 我们只是把 "microservice "换成了 "Lambda"。

**耦合的存在是因为系统不同部分之间的沟通方式，而不是支撑它的技术。**

![](images/lambda-coupling.png)

如果让一个组件通过调用公共接口的方式与另一个组件进行通信，那么无论底层技术如何，这些组件都是紧密耦合的。从这个角度来说。

**单体应用 ≈ 分布式单体 ≈ Serverless单体**

OMG，我们又搞砸了。为什么会这样？因为我们不知道新买来的工具怎么用。

我们知道了螺丝刀不是打钉子的合适工具，于是我们买了一个钻头，用它把钉子打碎了。我们的目标达到了吗？算是达到了，但还没有。

我们一直忽略的是，虽然我们可以用锤子、螺丝刀和钻头把两块木头连接在一起，但我们不能用钉子把所有的钉子都用上。

- 锤子需要用钉子。你敲打它。

- 螺丝起子需要一个螺栓。你拧紧它。

- 钻头需要一个全新的过程来完成任务。

同样的，**Serverless需要对我们的架构进行彻底的反思**，以便利大于弊（因为，是的！Serverless也有弊端）。


理想的情况下，无服务器架构与事件驱动的架构联合。这意味着，我们的Lambda函数不会直接依赖于其他函数。相反，它们会向某种 "事件总线"（Amazon SNS、Kinesis、RabbitMQ等）发出一个事件，然后就完成了。另一个Lambda可以对该事件做出反应，并进行进一步的处理，但它们不再耦合。如果这个后一个Lambda失败了，第一个Lambda根本就不在乎了。

这样我们就获得了完全隔离的组件、高容错率和惊人的可扩展性。

## 总结

- 在使用工具之前，先研究和了解他们。

- 事实上，一个架构在一个工具中工作得很好，并不意味着它在其他工具中也能很好地工作。

- 无服务器是一个非常强大的工具。学习如何使用好它，需要改变思维方式。另一方面，Serverless是一个非常复杂的工具。要特别小心，决定你是否真的需要它来解决你想解决的问题。

在此，我要特别提到我的队友和同事 Javier Toledo、Dana Peele、José Manuel Martínez和Abraham Romero，感谢他们帮助审阅这篇文章并提供建议。非常感谢你们!












